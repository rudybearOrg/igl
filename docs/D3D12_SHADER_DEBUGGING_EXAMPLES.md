# D3D12 Shader Debugging - Examples and Demos

This document provides practical examples of using the shader debugging features in the IGL D3D12 backend.

## Example 1: Basic Shader Compilation with Debug Info

### HLSL Shader Code

```hlsl
// SimpleShader.hlsl
cbuffer UniformsPerFrame : register(b0) {
    float4x4 viewProjection;
    float4 lightDirection;
};

cbuffer UniformsPerObject : register(b1) {
    float4x4 modelMatrix;
    float4 color;
};

struct VSInput {
    float3 position : POSITION;
    float3 normal : NORMAL;
    float2 uv : TEXCOORD0;
};

struct PSInput {
    float4 position : SV_POSITION;
    float3 normal : NORMAL;
    float2 uv : TEXCOORD0;
};

PSInput VSMain(VSInput input) {
    PSInput output;

    // Transform position to world space, then to clip space
    float4 worldPos = mul(modelMatrix, float4(input.position, 1.0));
    output.position = mul(viewProjection, worldPos);

    // Transform normal to world space
    output.normal = mul((float3x3)modelMatrix, input.normal);
    output.uv = input.uv;

    return output;
}

Texture2D albedoTexture : register(t0);
SamplerState albedoSampler : register(s0);

float4 PSMain(PSInput input) : SV_TARGET {
    // Sample texture
    float4 texColor = albedoTexture.Sample(albedoSampler, input.uv);

    // Simple lighting calculation
    float3 N = normalize(input.normal);
    float3 L = normalize(lightDirection.xyz);
    float ndotl = max(0.0, dot(N, L));

    // Combine with material color
    return texColor * color * ndotl;
}
```

### Compilation Output (Debug Build)

```
Device::createShaderModule() - stage=0, entryPoint='VSMain', debugName='SimpleShader_vs'
  Compiling HLSL from string (1234 bytes)...
  DEBUG BUILD: Enabling shader debug info and disabling optimizations
  Shader compiled successfully (4567 bytes bytecode)
```

### With Shader Reflection Enabled

Set environment variable:
```batch
set IGL_D3D12_VALIDATE_SHADER_BINDINGS=1
```

Output:
```
=== SHADER REFLECTION (VERTEX - VSMain) ===
  Bound Resources: 2
    [0] ConstantBuffer 'UniformsPerFrame' at b0 (space 0)
    [1] ConstantBuffer 'UniformsPerObject' at b1 (space 0)
  Constant Buffers: 2
    [0] UniformsPerFrame: 128 bytes, 2 variables
    [1] UniformsPerObject: 128 bytes, 2 variables
================================

=== SHADER REFLECTION (FRAGMENT/PIXEL - PSMain) ===
  Bound Resources: 4
    [0] ConstantBuffer 'UniformsPerFrame' at b0 (space 0)
    [1] Texture 'albedoTexture' at t0 (space 0)
    [2] Sampler 'albedoSampler' at s0 (space 0)
  Constant Buffers: 1
    [0] UniformsPerFrame: 128 bytes, 2 variables
================================
```

## Example 2: Shader Compilation Error

### Buggy Shader Code

```hlsl
cbuffer Uniforms : register(b0) {
    float4x4 mvpMatrix;  // Declared here
};

struct VSInput {
    float3 position : POSITION;
};

struct PSInput {
    float4 position : SV_POSITION;
};

PSInput VSMain(VSInput input) {
    PSInput output;
    // BUG: Typo in variable name!
    output.position = mul(mvpMatirx, float4(input.position, 1.0));
    return output;
}
```

### Enhanced Error Output

```
Shader compilation FAILED
  Stage: VERTEX
  Entry Point: VSMain
  Target: vs_5_0
  Debug Name: BuggyShader_vs

=== COMPILER ERRORS ===
BuggyShader_vs(18,27): error X3004: undeclared identifier 'mvpMatirx'
======================

HINT: Check source line 18,27 in the shader
```

**Before Enhancement** (old error message):
```
Shader compilation failed: error X3004: undeclared identifier 'mvpMatirx'
```

**After Enhancement**:
- Clear identification of shader stage and entry point
- Full context about what was being compiled
- Highlighted line number
- Helpful hint pointing to the exact location

## Example 3: Shader Disassembly Analysis

### Enable Disassembly

```batch
set IGL_D3D12_DISASSEMBLE_SHADERS=1
```

### Simple Vertex Shader

```hlsl
cbuffer Transforms : register(b0) {
    float4x4 mvp;
};

struct VSInput {
    float3 position : POSITION;
};

float4 VSMain(VSInput input) : SV_POSITION {
    return mul(mvp, float4(input.position, 1.0));
}
```

### Disassembly Output

```
=== SHADER DISASSEMBLY (VERTEX - VSMain) ===
//
// Generated by Microsoft (R) HLSL Shader Compiler 10.1
//
//
// Buffer Definitions:
//
// cbuffer Transforms
// {
//
//   float4x4 mvp;                      // Offset:    0 Size:    64
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim      ID      HLSL Bind  Count
// ------------------------------ ---------- ------- ----------- ------- -------------- ------
// Transforms                        cbuffer      NA          NA     CB0            cb0     1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITION                 0   xyz         0     NONE   float   xyz
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_POSITION              0   xyzw        0      POS   float   xyzw
//
vs_5_0
dcl_globalFlags refactoringAllowed | skipOptimization
dcl_constantbuffer CB0[0:0][4], immediateIndexed, space=0
dcl_input v0.xyz
dcl_output_siv o0.xyzw, position
dcl_temps 2
//
// Initial variable locations:
//   v0.x <- input.position.x; v0.y <- input.position.y; v0.z <- input.position.z;
//   o0.x <- <VSMain return value>.x; o0.y <- <VSMain return value>.y; o0.z <- <VSMain return value>.z; o0.w <- <VSMain return value>.w
//
#line 12 "C:\...\SimpleTransform_vs"
mov r0.xyz, v0.xyzx
mov r0.w, l(1.000000)
dp4 r1.x, cb0[0][0].xyzw, r0.xyzw
dp4 r1.y, cb0[0][1].xyzw, r0.xyzw
dp4 r1.z, cb0[0][2].xyzw, r0.xyzw
dp4 r1.w, cb0[0][3].xyzw, r0.xyzw
mov o0.xyzw, r1.xyzw
ret
// Approximately 8 instruction slots used
=========================
```

**Analysis**:
- 8 instruction slots (very efficient)
- Direct constant buffer access
- 4 dp4 (dot product) instructions for matrix multiply
- No optimization (skipOptimization flag in debug build)

## Example 4: PIX Debugging Session

### Setup

1. Compile shader with debug info (automatic in debug builds)
2. Run application
3. Launch PIX on Windows
4. Attach to process or capture GPU work

### Pipeline State Names in PIX

When you create a render pipeline with debug name:

```cpp
RenderPipelineDesc pipelineDesc;
pipelineDesc.debugName = "TerrainRenderer";
// ... configure pipeline ...
auto pipeline = device.createRenderPipeline(pipelineDesc, &result);
```

PIX will show:
- Pipeline State Object: `PSO_TerrainRenderer`
- Root Signature: `RootSig_TerrainRenderer`

### Debugging Workflow

1. **Set breakpoint** in pixel shader at line 42:
   ```hlsl
   float4 texColor = albedoTexture.Sample(albedoSampler, input.uv);
   ```

2. **Inspect variables**:
   - `input.uv` = `{0.5, 0.5}`
   - `albedoTexture` = valid texture resource
   - `albedoSampler` = valid sampler state

3. **Step through code** and watch values change

4. **View register allocation**:
   - `r0` = temporary for UV coordinates
   - `t0` = texture resource
   - `s0` = sampler state

## Example 5: Binding Validation

### Shader Definition

```hlsl
cbuffer PerFrame : register(b0) {
    float4x4 viewProj;
};

cbuffer PerObject : register(b1) {
    float4x4 world;
    float4 color;
};

cbuffer Material : register(b2) {
    float roughness;
    float metallic;
};

Texture2D baseColor : register(t0);
Texture2D normalMap : register(t1);
Texture2D roughnessMap : register(t2);

SamplerState linearSampler : register(s0);
```

### Reflection Output

```
=== SHADER REFLECTION (FRAGMENT/PIXEL - PSMain) ===
  Bound Resources: 7
    [0] ConstantBuffer 'PerFrame' at b0 (space 0)
    [1] ConstantBuffer 'PerObject' at b1 (space 0)
    [2] ConstantBuffer 'Material' at b2 (space 0)
    [3] Texture 'baseColor' at t0 (space 0)
    [4] Texture 'normalMap' at t1 (space 0)
    [5] Texture 'roughnessMap' at t2 (space 0)
    [6] Sampler 'linearSampler' at s0 (space 0)
  Constant Buffers: 3
    [0] PerFrame: 64 bytes, 1 variables
    [1] PerObject: 128 bytes, 2 variables
    [2] Material: 8 bytes, 2 variables
================================
```

**Validation Checks**:
- All 3 constant buffers are correctly bound to b0, b1, b2
- Textures use sequential t# registers
- Sampler correctly bound to s0
- Constant buffer sizes are aligned to 256-byte boundaries (after padding)

## Example 6: Compute Shader Debugging

### Compute Shader

```hlsl
RWTexture2D<float4> OutputTexture : register(u0);
Texture2D<float4> InputTexture : register(t0);

cbuffer Params : register(b0) {
    float2 resolution;
    float time;
    float intensity;
};

[numthreads(8, 8, 1)]
void CSMain(uint3 dispatchThreadID : SV_DispatchThreadID) {
    // Get pixel coordinates
    uint2 pixelPos = dispatchThreadID.xy;

    // Normalize coordinates
    float2 uv = float2(pixelPos) / resolution;

    // Sample input
    float4 color = InputTexture[pixelPos];

    // Apply effect
    color.rgb *= intensity;

    // Write output
    OutputTexture[pixelPos] = color;
}
```

### Compilation Output

```
Device::createComputePipeline() START - debugName='ImageProcessor'
  Getting compute shader bytecode...
  CS bytecode: 2048 bytes
  Creating compute root signature with UAVs/SRVs/CBVs/Samplers
  Compute root signature created OK
  Creating compute pipeline state...
Device::createComputePipeline() SUCCESS - PSO=0x..., RootSig=0x...
ComputePipelineState: Set PIX debug name 'ComputePSO_ImageProcessor'
ComputePipelineState: Set PIX root signature name 'ComputeRootSig_ImageProcessor'
```

### Reflection Output

```
=== SHADER REFLECTION (COMPUTE - CSMain) ===
  Bound Resources: 3
    [0] RWTexture 'OutputTexture' at u0 (space 0)
    [1] Texture 'InputTexture' at t0 (space 0)
    [2] ConstantBuffer 'Params' at b0 (space 0)
  Constant Buffers: 1
    [0] Params: 16 bytes, 3 variables
================================
```

## Example 7: Warnings as Errors

### Enable Strict Validation

```batch
set IGL_D3D12_SHADER_WARNINGS_AS_ERRORS=1
```

### Shader with Warning

```hlsl
cbuffer Uniforms : register(b0) {
    float4x4 mvp;
    float unused;  // WARNING: Unused variable
};

float4 VSMain(float3 pos : POSITION) : SV_POSITION {
    return mul(mvp, float4(pos, 1.0));
}
```

### Output

```
Shader compilation FAILED
  Stage: VERTEX
  Entry Point: VSMain
  Target: vs_5_0
  Debug Name: TestShader_vs

=== COMPILER ERRORS ===
TestShader_vs(3,11): warning X3557: 'unused': variable is defined but never used
Note: Treating warnings as errors (IGL_D3D12_SHADER_WARNINGS_AS_ERRORS=1)
======================
```

## Example 8: Release Build with Debug Info

### Release Build Configuration

By default, release builds still include debug info for PIX captures:

```
  RELEASE BUILD: Enabling shader debug info (disable with IGL_D3D12_DISABLE_SHADER_DEBUG=1)
```

**Characteristics**:
- Optimizations enabled
- Debug info included
- Slightly larger bytecode
- Debuggable in PIX

### Shipping Build (No Debug Info)

```batch
set IGL_D3D12_DISABLE_SHADER_DEBUG=1
```

Output:
```
  Shader compiled successfully (1234 bytes bytecode)
```

**Characteristics**:
- Optimizations enabled
- No debug info
- Minimal bytecode size
- Not debuggable in PIX

## Performance Comparison

### Shader Bytecode Sizes

| Configuration | Vertex Shader | Pixel Shader | Notes |
|--------------|--------------|--------------|-------|
| Debug (no opt) | 4,567 bytes | 6,789 bytes | Includes debug info + unoptimized |
| Release (debug) | 2,345 bytes | 3,456 bytes | Includes debug info + optimized |
| Shipping (no debug) | 1,234 bytes | 1,789 bytes | Minimal size, optimized |

### Compilation Times

| Configuration | Time | Notes |
|--------------|------|-------|
| Standard | 15ms | Basic compilation |
| + Debug Info | 18ms | +20% for debug embedding |
| + Disassembly | 23ms | +50% total |
| + Reflection | 28ms | +87% total |

**Note**: Reflection and disassembly only affect compilation time, not runtime performance.

## Common Debugging Scenarios

### Scenario 1: Black Screen Issue

**Problem**: Scene renders as black

**Debug Steps**:
1. Enable shader reflection to verify bindings
2. Use PIX to capture frame
3. Check pixel shader outputs
4. Verify texture bindings (t# registers)
5. Inspect constant buffer values

### Scenario 2: Performance Issue

**Problem**: Shader is too slow

**Debug Steps**:
1. Enable shader disassembly
2. Count instruction slots
3. Look for expensive operations (loops, branches)
4. Use PIX GPU profiling
5. Optimize based on assembly output

### Scenario 3: Binding Mismatch

**Problem**: Shader expects resources that aren't bound

**Debug Steps**:
1. Enable shader reflection
2. Compare shader expectations with pipeline setup
3. Verify register assignments match
4. Check constant buffer sizes and alignment

## Summary

The D3D12 shader debugging features provide:

1. **Automatic debug info** in all builds (configurable)
2. **Enhanced error messages** with full context
3. **Shader disassembly** for performance analysis
4. **Shader reflection** for binding validation
5. **PIX integration** via object naming
6. **Flexible control** via environment variables

These features work together to provide a comprehensive shader debugging experience.
