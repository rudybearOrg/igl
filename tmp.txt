 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include <igl/d3d12/Texture.h>

namespace igl::d3d12 {

std::shared_ptr<Texture> Texture::createFromResource(ID3D12Resource* resource,
                                                       TextureFormat format,
                                                       const TextureDesc& desc,
                                                       ID3D12Device* device,
                                                       ID3D12CommandQueue* queue) {
  if (!resource) {
    IGL_LOG_ERROR("Texture::createFromResource - resource is NULL!\n");
    return nullptr;
  }

  auto texture = std::make_shared<Texture>(format);

  // Attach the resource to ComPtr (takes ownership, AddRefs)
  resource->AddRef();
  texture->resource_.Attach(resource);

  texture->device_ = device;
  texture->queue_ = queue;
  texture->format_ = format;
  texture->dimensions_ = Dimensions{desc.width, desc.height, desc.depth};
  texture->type_ = desc.type;
  texture->numLayers_ = desc.numLayers;
  texture->numMipLevels_ = desc.numMipLevels;
  texture->samples_ = desc.numSamples;
  texture->usage_ = desc.usage;

  IGL_LOG_INFO("Texture::createFromResource - SUCCESS: %dx%d format=%d\n",
               desc.width, desc.height, (int)format);

  return texture;
}

Result Texture::upload(const TextureRangeDesc& range,
                      const void* data,
                      size_t bytesPerRow) const {
  IGL_LOG_INFO("Texture::upload() - START: %dx%d\n", range.width, range.height);

  if (!device_ || !queue_ || !resource_.Get()) {
    IGL_LOG_ERROR("Texture::upload() - FAILED: device, queue, or resource not available\n");
    return Result(Result::Code::RuntimeError, "Device, queue, or resource not available for upload");
  }

  if (!data) {
    IGL_LOG_ERROR("Texture::upload() - FAILED: data is null\n");
    return Result(Result::Code::ArgumentInvalid, "Upload data is null");
  }

  IGL_LOG_INFO("Texture::upload() - Proceeding with upload\n");

  // Calculate dimensions and data size
  const uint32_t width = range.width > 0 ? range.width : dimensions_.width;
  const uint32_t height = range.height > 0 ? range.height : dimensions_.height;

  // Calculate bytes per row if not provided
  if (bytesPerRow == 0) {
    const auto props = TextureFormatProperties::fromTextureFormat(format_);
    const size_t bpp = std::max<uint8_t>(props.bytesPerBlock, 1);
    bytesPerRow = static_cast<size_t>(width) * bpp;
  }

  // Get the resource description to calculate required size
  D3D12_RESOURCE_DESC resourceDesc = resource_->GetDesc();

  // Get the layout information for the subresource
  D3D12_PLACED_SUBRESOURCE_FOOTPRINT layout;
  UINT numRows;
  UINT64 rowSizeInBytes;
  UINT64 totalBytes;

  device_->GetCopyableFootprints(&resourceDesc, range.mipLevel, 1, 0,
                                  &layout, &numRows, &rowSizeInBytes, &totalBytes);

  // Create staging buffer (upload heap)
  D3D12_HEAP_PROPERTIES uploadHeapProps = {};
  uploadHeapProps.Type = D3D12_HEAP_TYPE_UPLOAD;
  uploadHeapProps.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
  uploadHeapProps.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;
  uploadHeapProps.CreationNodeMask = 1;
  uploadHeapProps.VisibleNodeMask = 1;

  D3D12_RESOURCE_DESC stagingDesc = {};
  stagingDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
  stagingDesc.Alignment = 0;
  stagingDesc.Width = totalBytes;
  stagingDesc.Height = 1;
  stagingDesc.DepthOrArraySize = 1;
  stagingDesc.MipLevels = 1;
  stagingDesc.Format = DXGI_FORMAT_UNKNOWN;
  stagingDesc.SampleDesc.Count = 1;
  stagingDesc.SampleDesc.Quality = 0;
  stagingDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
